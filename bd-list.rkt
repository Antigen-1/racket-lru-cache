#lang racket/base
(#%declare #:unsafe)

(require #;racket/contract (submod racket/performance-hint begin-encourage-inline))
(provide
 make-initial-node node-empty? node-right-empty? node-left-empty? delete-node! insert-node! insert-node!/right node-last node-next
 (rename-out (n:node-value node-value))
 ;; For illustration and testing
 #;(contract-out
  #:exists node
  (make-initial-node (-> node))
  (node-empty? (-> node boolean?))
  (node-right-empty? (-> node boolean?))
  (node-left-empty? (-> node boolean?))
  (delete-node! (-> node any))
  (insert-node! (-> node any/c node))
  (insert-node!/right (-> node any/c node))
  (node-last (-> node node))
  (node-next (-> node node))
  (rename n:node-value node-value
          (-> node any))))

(begin-encourage-inline
  (define (make-node value last next)
    (mcons value (mcons last next)))
  (define (node-value n)
    (mcar n))
  (define (node-last n)
    (mcar (mcdr n)))
  (define (node-next n)
    (mcdr (mcdr n)))
  (define (set-node-value! n v)
    (set-mcar! n v))
  (define (set-node-last! n l)
    (set-mcar! (mcdr n) l))
  (define (set-node-next! n nx)
    (set-mcdr! (mcdr n) nx))

  (define none (gensym))

  (define (make-initial-node)
    (make-node none null null))
  (define (node-empty? n)
    (eq? (node-value n) none))
  (define (node-left-empty? n)
    (null? (node-last n)))
  (define (node-right-empty? n)
    (null? (node-next n)))
  (define (n:node-value n)
    (if (node-empty? n)
        (raise-argument-error 'node-value "(lambda (n) (not (node-empty? n)))" n)
        (node-value n)))
  (define (delete-node! n)
    (or (and (node-empty? n) (raise-argument-error 'delete-node! "(lambda (n) (not (node-empty? n)))" n))
        (and (node-right-empty? n)
             (node-left-empty? n)
             (set-node-value! n none))
        (and (not (node-right-empty? n))
             (not (node-left-empty? n))
             (set-node-last! (node-next n) (node-last n))
             (set-node-next! (node-last n) (node-next n))
             (set-node-last! n null)
             (set-node-next! n null))
        (and (node-left-empty? n) (set-node-last! (node-next n) null) (set-node-next! n null))
        (and (node-right-empty? n) (set-node-next! (node-last n) null) (set-node-last! n null))))
  (define (insert-node! n v)
    (if (node-empty? n)
        (begin (set-node-value! n v) n)
        (let* ((ls (node-last n))
               (nn (make-node v ls n)))
          (set-node-last! n nn)
          (cond ((not (null? ls)) (set-node-next! ls nn)))
          nn)))
  (define (insert-node!/right n v)
    (if (node-empty? n)
        (begin (set-node-value! n v) n)
        (let* ((nx (node-next n))
               (nn (make-node v n nx)))
          (set-node-next! n nn)
          (cond ((not (null? nx)) (set-node-last! nx nn)))
          nn)))
  )

(module+ test
  (require rackunit)

  (check-equal? (make-initial-node) (mcons none (mcons null null)))
  (check-exn exn:fail:contract? (lambda () (delete-node! (make-initial-node))))
  (check-equal? (insert-node! (make-initial-node) 1) (mcons 1 (mcons null null)))
  (check-equal? (insert-node! (insert-node! (make-initial-node) 1) 2)
                (let* ((n (insert-node! (insert-node! (insert-node! (make-initial-node) 1) 2) 3))
                       (nx (node-next n)))
                  (delete-node! n)
                  nx))
  (check-equal? (insert-node! (insert-node! (make-initial-node) 1) 2)
                (let* ((n (insert-node! (insert-node! (insert-node! (make-initial-node) 1) 3) 2))
                       (nx (node-next n)))
                  (delete-node! nx)
                  n))
  (check-equal? (insert-node!/right (make-initial-node) 1)
                (insert-node! (make-initial-node) 1))
  (check-equal? (node-last (insert-node!/right (insert-node!/right (make-initial-node) 2) 1))
                (insert-node! (insert-node! (make-initial-node) 1) 2))
  (check-equal? (let ((node (make-initial-node)))
                  (set-node-value! node 1)
                  (delete-node! node)
                  node)
                (make-initial-node))
  (check-true (node-left-empty? (make-initial-node)))
  (check-true (node-right-empty? (make-initial-node)))
  (check-true (node-empty? (make-initial-node))))
